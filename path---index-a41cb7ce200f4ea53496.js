webpackJsonp([0x81b8806e4260],{868:function(e,t){e.exports={data:{code:{edges:[{node:{id:"a-component-using-external-plugins",internal:{contentDigest:'"class MarkdownEditor extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.handleChange = this.handleChange.bind(this);\\n    this.state = { value: \'Hello, **world**!\' };\\n  }\\n\\n  handleChange(e) {\\n    this.setState({ value: e.target.value });\\n  }\\n\\n  getRawMarkup() {\\n    const md = new Remarkable();\\n    return { __html: md.render(this.state.value) };\\n  }\\n\\n  render() {\\n    return (\\n      <div className=\\"MarkdownEditor\\">\\n        <h3>Input</h3>\\n        <label htmlFor=\\"markdown-content\\">\\n          Enter some markdown\\n        </label>\\n        <textarea\\n          id=\\"markdown-content\\"\\n          onChange={this.handleChange}\\n          defaultValue={this.state.value}\\n        />\\n        <h3>Output</h3>\\n        <div\\n          className=\\"content\\"\\n          dangerouslySetInnerHTML={this.getRawMarkup()}\\n        />\\n      </div>\\n    );\\n  }\\n}\\n\\nReactDOM.render(<MarkdownEditor />, mountNode);"'}}},{node:{id:"a-simple-component",internal:{contentDigest:'"class HelloMessage extends React.Component {\\n  render() {\\n    return (\\n      <div>\\n        Hello {this.props.name}\\n      </div>\\n    );\\n  }\\n}\\n\\nReactDOM.render(\\n  <HelloMessage name=\\"Taylor\\" />,\\n  mountNode\\n);"'}}},{node:{id:"a-stateful-component",internal:{contentDigest:'"class Timer extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.state = { seconds: 0 };\\n  }\\n\\n  tick() {\\n    this.setState(prevState => ({\\n      seconds: prevState.seconds + 1\\n    }));\\n  }\\n\\n  componentDidMount() {\\n    this.interval = setInterval(() => this.tick(), 1000);\\n  }\\n\\n  componentWillUnmount() {\\n    clearInterval(this.interval);\\n  }\\n\\n  render() {\\n    return (\\n      <div>\\n        Seconds: {this.state.seconds}\\n      </div>\\n    );\\n  }\\n}\\n\\nReactDOM.render(<Timer />, mountNode);"'}}},{node:{id:"an-application",internal:{contentDigest:'"class TodoApp extends React.Component {\\n  constructor(props) {\\n    super(props);\\n    this.state = { items: [], text: \'\' };\\n    this.handleChange = this.handleChange.bind(this);\\n    this.handleSubmit = this.handleSubmit.bind(this);\\n  }\\n\\n  render() {\\n    return (\\n      <div>\\n        <h3>TODO</h3>\\n        <TodoList items={this.state.items} />\\n        <form onSubmit={this.handleSubmit}>\\n          <label htmlFor=\\"new-todo\\">\\n            What needs to be done?\\n          </label>\\n          <input\\n            id=\\"new-todo\\"\\n            onChange={this.handleChange}\\n            value={this.state.text}\\n          />\\n          <button>\\n            Add #{this.state.items.length + 1}\\n          </button>\\n        </form>\\n      </div>\\n    );\\n  }\\n\\n  handleChange(e) {\\n    this.setState({ text: e.target.value });\\n  }\\n\\n  handleSubmit(e) {\\n    e.preventDefault();\\n    if (!this.state.text.length) {\\n      return;\\n    }\\n    const newItem = {\\n      text: this.state.text,\\n      id: Date.now()\\n    };\\n    this.setState(prevState => ({\\n      items: prevState.items.concat(newItem),\\n      text: \'\'\\n    }));\\n  }\\n}\\n\\nclass TodoList extends React.Component {\\n  render() {\\n    return (\\n      <ul>\\n        {this.props.items.map(item => (\\n          <li key={item.id}>{item.text}</li>\\n        ))}\\n      </ul>\\n    );\\n  }\\n}\\n\\nReactDOM.render(<TodoApp />, mountNode);\\n"'}}}]},examples:{edges:[{node:{fields:{slug:"/home/examples/a-simple-component.html"},frontmatter:{title:"最簡單的元件"},html:'<p>React 元件提供了 <code class="gatsby-code-text">render()</code> 函式，藉由輸入資料來輸出希望顯示的畫面。下面這個範例使用了被稱為 JSX 的類 XML 語法。<code class="gatsby-code-text">render</code> 所需的資料從 <code class="gatsby-code-text">this.props</code> 裡取得。</p>\n<p><strong>使用 React 並不一定得使用 JSX。</strong> 請到 <a href="https://babeljs.io/repl/#?presets=react&code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bx4gA" target="_blank" rel="noreferrer">Babel REPL</a> 看看如何只使用 JavaScript 渲染畫面。</p>'}},{node:{fields:{slug:"/home/examples/a-stateful-component.html"},frontmatter:{title:"有狀態的元件"},html:'<p>有別於來自外部的資料 <code class="gatsby-code-text">this.props</code>，一個元件也可以擁有其自身的內部狀態 - <code class="gatsby-code-text">this.state</code>。當元件的內部狀態改變時，<code class="gatsby-code-text">render()</code> 也會被觸發。</p>'}},{node:{fields:{slug:"/home/examples/an-application.html"},frontmatter:{title:"應用程式範例"},html:'<p>藉由 <code class="gatsby-code-text">props</code> 及 <code class="gatsby-code-text">state</code>，我們可以建立一個簡單的待辦事項應用程式。下面這個案例我們使用 <code class="gatsby-code-text">state</code> 紀錄目前的使用者輸入的清單。所有的事件響應函式是以 event delegation 的方式實作。</p>'}},{node:{fields:{slug:"/home/examples/a-component-using-external-plugins.html"},frontmatter:{title:"使用外部套件的元件"},html:'<p>React 十分有彈性，它讓您很容易掛載其他第三方的函式庫及框架。下方的範例掛載了一個 Markdown 函式庫 <strong>remarkable</strong>，讓 <code class="gatsby-code-text">&lt;textarea&gt;</code> 的內容值能即時顯示。</p>'}}]},marketing:{edges:[{node:{frontmatter:{title:"宣告式編程"},html:"<p>React 的技術特點讓您能無痛的創建互動式介面。您只需描述應用程式內的畫面在各個狀態的呈現， React 便會高效的根據資料變動來更新畫面。</p>\n<p>宣告式的介面撰寫讓您能更好地掌握程式邏輯及除錯。</p>"}},{node:{frontmatter:{title:"基於原件"},html:"<p>在 React 中，我們撰寫高聚合低耦合的元件，並藉由組合他們來構建複雜的畫面。</p>\n<p>此外，因為藉由 JavaScript 而非樣板描述元件邏輯，您可以很輕易的在應用程式內調動大量資料並不影響實際的 DOM 佈局。</p>"}},{node:{frontmatter:{title:"一次學習，處處可寫"},html:'<p>React 對應用程式不做任何多餘的假設，是以您可以很容易的重新撰寫既存的程式碼。</p>\n<p>除了在瀏覽器執行之外，React 同時可在伺服器端 (藉由 Node) 及手機應用內 (藉由 <a href="https://facebook.github.io/react-native/">React Native</a>) 執行。</p>'}}]}},pathContext:{}}}});
//# sourceMappingURL=path---index-a41cb7ce200f4ea53496.js.map